#!/usr/bin/env bash
# Unified GitHub/Gitea CLI wrapper for agent workflows
# Provides LCD (Lowest Common Denominator) commands that work across both forges

set -euo pipefail

NIXSMITH_CONFIG="${HOME}/.config/nixsmith"

# Wrapper for tea that uses nixsmith namespace
run_tea() {
    XDG_CONFIG_HOME="${NIXSMITH_CONFIG}" tea "$@"
}

# Detect forge type from git remote
detect_forge() {
    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null || echo "")
    
    if [[ "$remote_url" =~ github\.com ]]; then
        echo "github"
    elif [[ "$remote_url" =~ gitlab\.com ]]; then
        echo "gitlab"
    elif [[ "$remote_url" =~ gitea ]]; then
        echo "gitea"
    else
        echo "unknown"
    fi
}

# Authenticate GitHub
authenticate_github() {
    if [[ -f "${NIXSMITH_CONFIG}/github-token" ]]; then
        export GH_TOKEN=$(cat "${NIXSMITH_CONFIG}/github-token")
    elif gh auth status &>/dev/null 2>&1; then
        echo "âš ï¸  Warning: Using dev's gh auth. Set up agent tokens: tools/setup-agent-api-tokens.sh" >&2
    else
        echo "Error: No GitHub authentication." >&2
        echo "Run: tools/setup-agent-api-tokens.sh" >&2
        exit 1
    fi
}

# Authenticate Gitea
authenticate_gitea() {
    if ! run_tea repos list >/dev/null 2>&1; then
        echo "Error: Gitea not authenticated." >&2
        echo "Run: tools/setup-agent-api-tokens.sh" >&2
        exit 1
    fi
}

FORGE_TYPE=$(detect_forge)

# Ensure we have the right CLI tool and authenticate
case "$FORGE_TYPE" in
    github)
        if ! command -v gh >/dev/null; then
            echo "Error: gh CLI not found. Install with: nix-env -iA nixpkgs.gh" >&2
            exit 1
        fi
        authenticate_github
        ;;
    gitea)
        if ! command -v tea >/dev/null; then
            echo "Error: tea CLI not found. Install with: nix-env -iA nixpkgs.tea" >&2
            exit 1
        fi
        authenticate_gitea
        ;;
    *)
        echo "Error: Unknown forge type. Remote must be GitHub or Gitea." >&2
        exit 1
        ;;
esac

auto_detect_pr() {
    local branch
    branch=$(git branch --show-current 2>/dev/null || echo "")
    
    if [[ -z "$branch" ]]; then
        echo "Error: Not on a branch (detached HEAD?)" >&2
        return 1
    fi
    
    case "$FORGE_TYPE" in
        github)
            # Try to find PR for current branch
            local pr_number
            pr_number=$(gh pr list --head "$branch" --json number --jq '.[0].number' 2>/dev/null || echo "")
            
            if [[ -z "$pr_number" ]]; then
                echo "Error: No PR found for branch '$branch'. Create one with: forge pr create" >&2
                return 1
            fi
            
            echo "$pr_number"
            ;;
        gitea)
            # tea doesn't have --head flag, need to parse list output
            local pr_number
            pr_number=$(run_tea pr list --output simple | grep -E "^[0-9]+" | while read num title rest; do
                local pr_branch=$(run_tea pr "$num" --output simple 2>/dev/null | grep -E "^Head Branch:" | cut -d: -f2 | xargs)
                if [[ "$pr_branch" == "$branch" ]]; then
                    echo "$num"
                    break
                fi
            done)
            
            if [[ -z "$pr_number" ]]; then
                echo "Error: No PR found for branch '$branch'. Create one with: forge pr create" >&2
                return 1
            fi
            
            echo "$pr_number"
            ;;
    esac
}

# Show usage
usage() {
    cat <<EOF
Usage: forge <command> [options]

Unified CLI for GitHub (gh) and Gitea (tea) operations.
Auto-detects forge type from git remote.

Commands:
  pr create --title TITLE --body BODY [--draft]
  pr view [NUMBER] [--json]
  pr comment [NUMBER] TEXT
  pr comments [NUMBER] [--json]
  pr list [--state STATE]
  pr checkout [NUMBER]
  pr approve [NUMBER]
  pr reviews [NUMBER] [--json]
  pr review-reply [NUMBER] COMMENT_ID TEXT

  issue list [--state STATE]
  issue show NUMBER

Options:
  --json           Output in JSON format (where supported)
  --state STATE    Filter by state: open, closed, all (space-separated)

Note: Use space-separated arguments (e.g., --state open, not --state=open)

Examples:
  forge pr create --title "Fix bug" --body "Description"
  forge pr list --state open --json
  forge pr view 123
  forge pr comments 123
  forge pr review-reply 123 456789 "Fixed in commit abc123"
  forge pr comment 123 "Looks good!"
  forge pr approve 123

Current forge: $FORGE_TYPE
EOF
}

# PR commands
pr_create() {
    local title="" body="" draft=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --title) title="$2"; shift 2 ;;
            --body) body="$2"; shift 2 ;;
            --draft) draft=true; shift ;;
            --title=*|--body=*)
                echo "Error: Use space-separated arguments (e.g., --title 'text', not --title='text')" >&2
                exit 1
                ;;
            *) echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done
    
    if [[ -z "$title" ]]; then
        echo "Error: --title required" >&2
        exit 1
    fi
    
    # Add agent signature if in agent environment
    if [[ -n "${IN_AGENT_SANDBOX:-}" ]] || [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
        body="${body}

---
*ðŸ¤– Created by agent*"
    fi
    
    # Show PR workflow guidelines
    if command -v temper >/dev/null 2>&1 && [[ -f AGENTS.md ]]; then
        echo "ðŸ“‹ PR Creation Guidelines:"
        echo ""
        temper pr
        echo ""
        echo "Creating PR..."
        echo ""
    fi
    
    case "$FORGE_TYPE" in
        github)
            local args=(--title "$title")
            [[ -n "$body" ]] && args+=(--body "$body")
            [[ "$draft" == true ]] && args+=(--draft)
            gh pr create "${args[@]}"
            ;;
        gitea)
            local args=(--title "$title")
            [[ -n "$body" ]] && args+=(--description "$body")
            [[ "$draft" == true ]] && args+=(--draft)
            run_tea pr create "${args[@]}"
            ;;
    esac
}

pr_view() {
    local number="${1:-}"
    [[ -n "$number" ]] && shift
    
    # Auto-detect PR if no number provided
    if [[ -z "$number" ]]; then
        number=$(auto_detect_pr) || exit 1
    fi
    
    local json_output=false json_fields=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                json_output=true
                # If next arg doesn't start with --, treat it as fields
                if [[ $# -gt 1 ]] && [[ ! "$2" =~ ^-- ]]; then
                    json_fields="$2"
                    shift
                fi
                shift
                ;;
            *) echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done
    
    case "$FORGE_TYPE" in
        github)
            if [[ "$json_output" == true ]]; then
                local fields="${json_fields:-body,title,state,number,comments}"
                gh pr view "$number" --json "$fields" | jq '. + {comment_count: (.comments | length)}'
            else
                # Show PR metadata
                gh pr view "$number"
                
                # Always show comments
                echo ""
                echo "Comments:"
                echo ""
                pr_comments "$number"
            fi
            ;;
        gitea)
            if [[ "$json_output" == true ]]; then
                run_tea pr "$number" --output json
            else
                run_tea pr "$number"
                echo ""
                echo "Comments:"
                echo ""
                pr_comments "$number"
            fi
            ;;
    esac
}

pr_status() {
    # Display formatted PR status for current branch
    # Shows warning for merged PRs, confirmation for open PRs, nothing if no PR exists
    local branch
    branch=$(git branch --show-current 2>/dev/null || echo "")
    
    if [[ -z "$branch" ]] || [[ "$branch" == "main" ]]; then
        return 0
    fi
    
    local pr_json
    case "$FORGE_TYPE" in
        github)
            pr_json=$(gh pr view --json number,state 2>/dev/null || echo "")
            ;;
        gitea)
            # tea doesn't have direct branch->PR lookup, fall back to list
            pr_json=$(run_tea pr list --output json 2>/dev/null | \
                jq -c ".[] | select(.head.ref==\"$branch\") | {number, state}" 2>/dev/null || echo "")
            ;;
    esac
    
    if [[ -z "$pr_json" ]]; then
        return 0
    fi
    
    local pr_num pr_state
    pr_num=$(echo "$pr_json" | jq -r '.number' 2>/dev/null)
    pr_state=$(echo "$pr_json" | jq -r '.state' 2>/dev/null)
    
    if [[ -n "$pr_num" ]] && [[ -n "$pr_state" ]]; then
        case "$pr_state" in
            MERGED)
                echo "âš ï¸  Branch has merged PR #${pr_num} - consider: git checkout main"
                ;;
            OPEN)
                echo "âœ“ PR #${pr_num} is open"
                ;;
        esac
    fi
}

pr_comment() {
    local number="${1:-}"
    local text="${2:-}"
    
    # Auto-detect PR if first arg looks like text (doesn't start with digit)
    if [[ -z "$number" ]] || [[ ! "$number" =~ ^[0-9]+$ ]]; then
        # First arg is text, not number
        text="$number"
        number=$(auto_detect_pr) || exit 1
    fi
    
    if [[ -z "$text" ]]; then
        echo "Error: Comment text required" >&2
        exit 1
    fi
    
    # Add agent signature if in agent environment
    if [[ -n "${IN_AGENT_SANDBOX:-}" ]] || [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
        text="${text}

---
*ðŸ¤– Posted by agent*"
    fi
    
    case "$FORGE_TYPE" in
        github)
            gh pr comment "$number" --body "$text"
            ;;
        gitea)
            run_tea pr comment "$number" "$text"
            ;;
    esac
}

pr_list() {
    local state="open"
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --state) state="$2"; shift 2 ;;
            --json) json_output=true; shift ;;
            *) echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done
    
    case "$FORGE_TYPE" in
        github)
            local args=(--state "$state")
            [[ "$json_output" == true ]] && args+=(--json number,title,state,headRefName)
            gh pr list "${args[@]}"
            ;;
        gitea)
            local args=(--state "$state")
            [[ "$json_output" == true ]] && args+=(--output json)
            run_tea pr list "${args[@]}"
            ;;
    esac
}

pr_checkout() {
    local number="${1:-}"
    
    # Auto-detect PR if no number provided
    if [[ -z "$number" ]]; then
        number=$(auto_detect_pr) || exit 1
    fi
    
    case "$FORGE_TYPE" in
        github)
            gh pr checkout "$number"
            ;;
        gitea)
            run_tea pr checkout "$number"
            ;;
    esac
}

pr_approve() {
    local number="${1:-}"
    
    # Auto-detect PR if no number provided
    if [[ -z "$number" ]]; then
        number=$(auto_detect_pr) || exit 1
    fi
    
    case "$FORGE_TYPE" in
        github)
            gh pr review "$number" --approve
            ;;
        gitea)
            run_tea pr approve "$number"
            ;;
    esac
}

pr_reviews() {
    local number="${1:-}"
    [[ -n "$number" ]] && shift
    
    # Auto-detect PR if no number provided
    if [[ -z "$number" ]]; then
        number=$(auto_detect_pr) || exit 1
    fi
    
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json) json_output=true; shift ;;
            *) echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done
    
    case "$FORGE_TYPE" in
        github)
            if [[ "$json_output" == true ]]; then
                gh api "repos/{owner}/{repo}/pulls/${number}/reviews"
            else
                gh api "repos/{owner}/{repo}/pulls/${number}/reviews" --jq '.[] | "Review #\(.id) by \(.user.login) (\(.state)):\n\(.body)\n---"'
            fi
            ;;
        gitea)
            echo "Error: Review listing not implemented for Gitea" >&2
            exit 1
            ;;
    esac
}

pr_comments() {
    local number="${1:-}"
    [[ -n "$number" ]] && shift
    
    # Auto-detect PR if no number provided
    if [[ -z "$number" ]]; then
        number=$(auto_detect_pr) || exit 1
    fi
    
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json) json_output=true; shift ;;
            *) echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done
    
    case "$FORGE_TYPE" in
        github)
            if [[ "$json_output" == true ]]; then
                # Return both general and review comments as JSON
                echo '{"general":' && gh api "repos/{owner}/{repo}/issues/${number}/comments" && echo ',"review":' && gh api "repos/{owner}/{repo}/pulls/${number}/comments" && echo '}'
            else
                # Fetch general comments (issue/PR conversation)
                local general_comments
                general_comments=$(gh api "repos/{owner}/{repo}/issues/${number}/comments" --jq '.[] | "[general] @\(.user.login)\n\(.body)\n"' 2>/dev/null || echo "")
                
                # Fetch review comments (code-specific)
                local review_comments
                review_comments=$(gh api "repos/{owner}/{repo}/pulls/${number}/comments" --jq '.[] | "[\(.id)] \(.path):\(.original_start_line // .start_line // .line)-\(.original_line // .line) @\(.user.login)\n\(.body)\n\(.diff_hunk)\n"' 2>/dev/null || echo "")
                
                # Output both
                if [[ -n "$general_comments" ]]; then
                    echo "$general_comments"
                fi
                
                if [[ -n "$review_comments" ]]; then
                    echo "$review_comments"
                fi
                
                # If neither, show message
                if [[ -z "$general_comments" ]] && [[ -z "$review_comments" ]]; then
                    echo "No comments found"
                fi
            fi
            ;;
        gitea)
            echo "Error: Comments not implemented for Gitea" >&2
            exit 1
            ;;
    esac
}

pr_review_reply() {
    local number="${1:-}"
    local comment_id="${2:-}"
    local text="${3:-}"
    
    # Auto-detect PR if first arg looks like comment ID (all digits, typically long)
    if [[ -z "$number" ]] || [[ -z "$comment_id" ]] || [[ -z "$text" ]]; then
        # Try auto-detect if only 2 args provided (comment_id + text)
        if [[ -n "$number" ]] && [[ -n "$comment_id" ]] && [[ -z "$text" ]]; then
            text="$comment_id"
            comment_id="$number"
            number=$(auto_detect_pr) || exit 1
        else
            echo "Error: Usage: forge pr review-reply [PR_NUMBER] COMMENT_ID TEXT" >&2
            exit 1
        fi
    fi
    
    # Add agent signature if in agent environment
    if [[ -n "${IN_AGENT_SANDBOX:-}" ]] || [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
        text="${text}

---
*ðŸ¤– Posted by agent*"
    fi
    
    case "$FORGE_TYPE" in
        github)
            gh api \
                --method POST \
                "repos/{owner}/{repo}/pulls/${number}/comments" \
                -f body="$text" \
                -F in_reply_to="$comment_id" \
                --jq '"Posted reply to review comment \(.id)"'
            ;;
        gitea)
            echo "Error: Review comment replies not supported for Gitea" >&2
            exit 1
            ;;
    esac
}

# Issue commands
issue_list() {
    local state="open"
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --state) state="$2"; shift 2 ;;
            --json) json_output=true; shift ;;
            --state=*)
                echo "Error: Use space-separated arguments: --state open (not --state=open)" >&2
                exit 1
                ;;
            *) echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done
    
    case "$FORGE_TYPE" in
        github)
            local args=(--state "$state")
            [[ "$json_output" == true ]] && args+=(--json number,title,state)
            gh issue list "${args[@]}"
            ;;
        gitea)
            local args=(--state "$state")
            [[ "$json_output" == true ]] && args+=(--output json)
            run_tea issue list "${args[@]}"
            ;;
    esac
}

issue_show() {
    local number="$1"
    shift
    
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json) json_output=true; shift ;;
            *) echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done
    
    case "$FORGE_TYPE" in
        github)
            local args=("$number")
            [[ "$json_output" == true ]] && args+=(--json number,title,body,state)
            gh issue view "${args[@]}"
            ;;
        gitea)
            local args=("$number")
            [[ "$json_output" == true ]] && args+=(--output json)
            run_tea issue "$number" "${args[@]}"
            ;;
    esac
}

# Main command router
case "${1:-}" in
    pr)
        case "${2:-}" in
            create) shift 2; pr_create "$@" ;;
            view) shift 2; pr_view "$@" ;;
            status) shift 2; pr_status "$@" ;;
            comment) shift 2; pr_comment "$@" ;;
            comments) shift 2; pr_comments "$@" ;;
            list) shift 2; pr_list "$@" ;;
            checkout) shift 2; pr_checkout "$@" ;;
            approve) shift 2; pr_approve "$@" ;;
            reviews) shift 2; pr_reviews "$@" ;;
            review-reply) shift 2; pr_review_reply "$@" ;;
            *) usage; exit 1 ;;
        esac
        ;;
    issue)
        case "${2:-}" in
            list) shift 2; issue_list "$@" ;;
            show) shift 2; issue_show "$@" ;;
            *) usage; exit 1 ;;
        esac
        ;;
    --help|-h|help|"")
        usage
        ;;
    *)
        echo "Unknown command: $1" >&2
        usage
        exit 1
        ;;
esac
