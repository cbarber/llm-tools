#!/usr/bin/env bash
# PR polling daemon - monitors PR status and notifies on changes
# Usage: pr-poll [--interval SECONDS] [--daemon]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
STATE_FILE="${REPO_DIR}/.pr-poll-state.json"
INTERVAL=${PR_POLL_INTERVAL:-30}
DAEMON_MODE=false

# Check if repo uses GitHub (pr-poll only supports GitHub currently)
FORGE_TYPE=$(bash "${SCRIPT_DIR}/forge" --type 2>/dev/null || echo "unknown")
if [[ "$FORGE_TYPE" != "github" ]]; then
    echo "pr-poll only supports GitHub repositories (detected: $FORGE_TYPE)" >&2
    echo "Skipping PR polling." >&2
    exit 0
fi

# Get git remote URL to filter sessions working on this specific repo
GIT_REMOTE=$(git remote get-url origin 2>/dev/null || echo "")
if [[ -n "$GIT_REMOTE" ]]; then
    # Extract repo path from URL (works for both SSH and HTTPS)
    # git@github.com:owner/repo.git -> github.com/owner/repo
    # https://github.com/owner/repo.git -> github.com/owner/repo
    REPO_PATH=$(echo "$GIT_REMOTE" | sed -E 's#^(https://|git@)##' | sed 's#:#/#' | sed 's#\.git$##')
else
    REPO_PATH=""
fi

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --interval)
            INTERVAL="$2"
            shift 2
            ;;
        --daemon)
            DAEMON_MODE=true
            shift
            ;;
        --help|-h)
            cat <<EOF
PR polling daemon - monitors PR status and notifies on changes

Usage:
  pr-poll                    # Run once, check for changes
  pr-poll --daemon           # Run continuously (every 30s)
  pr-poll --interval 60      # Custom interval in seconds

State file: ${REPO_DIR}/.pr-poll-state.json

Add .pr-poll-state.json to .gitignore
EOF
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# Initialize state file if doesn't exist
if [[ ! -f "$STATE_FILE" ]]; then
    echo '{}' > "$STATE_FILE"
fi

# Format a single comment for display
format_comment() {
    local comment="$1"
    local is_reply="$2"  # true if this is a reply in a thread
    
    local id=$(echo "$comment" | jq -r '.id')
    local author=$(echo "$comment" | jq -r '.user.login')
    local body=$(echo "$comment" | jq -r '.body')
    local path=$(echo "$comment" | jq -r '.path // "general"')
    local position=$(echo "$comment" | jq -r '.position // .original_position // "null"')
    local diff_hunk=$(echo "$comment" | jq -r '.diff_hunk // ""')
    
    local output=""
    if [[ "$is_reply" == "true" ]]; then
        output="  â†³ Reply to previous comment\n"
    fi
    
    output+="[$id] $path:$position @$author\n"
    output+="$body\n"
    
    if [[ -n "$diff_hunk" ]]; then
        output+="$diff_hunk\n"
    fi
    
    echo -e "$output"
}

# Build thread context for a comment (walks up to root, then formats entire thread)
build_comment_thread() {
    local all_comments="$1"
    local comment_id="$2"
    
    # Find the comment
    local comment=$(echo "$all_comments" | jq --argjson id "$comment_id" '
        (.general + .review) | map(select(.id == $id)) | .[0]
    ')
    
    if [[ "$comment" == "null" ]]; then
        return
    fi
    
    # Walk up to find root comment
    local root_id="$comment_id"
    local current_id="$comment_id"
    while true; do
        local in_reply_to=$(echo "$all_comments" | jq --argjson id "$current_id" '
            (.general + .review) | map(select(.id == $id)) | .[0].in_reply_to_id // null
        ')
        if [[ "$in_reply_to" == "null" ]]; then
            root_id="$current_id"
            break
        fi
        current_id="$in_reply_to"
        root_id="$current_id"
    done
    
    # Collect all comments in thread (root + all descendants)
    local thread_comments=$(echo "$all_comments" | jq --argjson root "$root_id" '
        (.general + .review) as $all |
        # Find root and all comments that reply to root (directly or indirectly)
        $all | map(select(
            .id == $root or .in_reply_to_id == $root
        ))
    ')
    
    # Format thread
    local output=""
    local is_first=true
    while IFS= read -r thread_comment; do
        if [[ "$is_first" == "true" ]]; then
            output+=$(format_comment "$thread_comment" "false")
            is_first=false
        else
            output+="\n"
            output+=$(format_comment "$thread_comment" "true")
        fi
    done < <(echo "$thread_comments" | jq -c '.[]')
    
    echo -e "$output"
}

# Get current PR state from forge
get_pr_state() {
    local pr_number="$1"
    local state=$(bash "${SCRIPT_DIR}/forge" pr view "$pr_number" --json 2>/dev/null)
    if [[ -z "$state" ]]; then
        echo "{}"
        return 1
    fi
    
    # Get all comments (including bot comments for state tracking)
    local comments=$(bash "${SCRIPT_DIR}/forge" pr comments "$pr_number" --json 2>/dev/null || echo '{"general":[],"review":[]}')
    
    # Track ALL comment IDs in state (including bot comments)
    local all_comment_ids=$(echo "$comments" | jq '
        (.general + .review) | map(.id)
    ')
    
    echo "$state" | jq \
        --argjson ids "$all_comment_ids" \
        --argjson comments "$comments" \
        '. + {comment_ids: $ids, comments: $comments, last_check: now}'
}

# Check for changes and notify if needed
check_pr() {
    local pr_number="$1"
    
    # Get current state
    local current_state=$(get_pr_state "$pr_number")
    if [[ "$current_state" == "{}" ]]; then
        echo "Failed to fetch PR #$pr_number state" >&2
        return 1
    fi
    
    # Get previous state from file (keep as JSON, not raw string)
    local previous_state=$(jq --arg pr "$pr_number" '.[$pr] // {}' "$STATE_FILE")
    
    # Extract fields for comparison
    local curr_pr_state=$(echo "$current_state" | jq -r '.state')
    local prev_pr_state=$(echo "$previous_state" | jq -r '.state // "unknown"')
    
    # Treat null/empty as unknown (happens when state file is empty or PR not yet tracked)
    if [[ "$prev_pr_state" == "null" || -z "$prev_pr_state" ]]; then
        prev_pr_state="unknown"
    fi
    
    # Get comment IDs for comparison
    local curr_comment_ids=$(echo "$current_state" | jq -r '.comment_ids // []')
    local prev_comment_ids=$(echo "$previous_state" | jq -r '.comment_ids // []')
    
    # Find new comment IDs (excluding bot comments for notification)
    local new_comment_ids=$(echo "$curr_comment_ids" | jq -r --argjson prev "$prev_comment_ids" '
        map(select(. as $id | $prev | index($id) | not))
    ')
    
    # Filter out bot comments from new comment IDs
    local all_comments=$(echo "$current_state" | jq -r '.comments')
    local new_non_bot_ids=$(echo "$all_comments" | jq -r --argjson new_ids "$new_comment_ids" '
        (.general + .review) | 
        map(select(
            (.id as $id | $new_ids | index($id) != null) and
            (.body | endswith("*ðŸ¤– Posted by agent*") | not)
        )) | 
        map(.id)
    ')
    
    # Detect changes
    local changes=()
    local new_comment_threads=""
    if [[ "$prev_pr_state" == "unknown" ]]; then
        echo "First check for PR #$pr_number - no notification" >&2
    else
        if [[ "$curr_pr_state" != "$prev_pr_state" ]]; then
            changes+=("Status changed: $prev_pr_state â†’ $curr_pr_state")
        fi
        
        # Check for new non-bot comments
        local new_ids_array=($(echo "$new_non_bot_ids" | jq -r '.[]'))
        if [[ ${#new_ids_array[@]} -gt 0 ]]; then
            changes+=("${#new_ids_array[@]} new comment(s)")
            
            new_comment_threads+="New comments:\n\n"
            for comment_id in "${new_ids_array[@]}"; do
                local thread=$(build_comment_thread "$all_comments" "$comment_id")
                new_comment_threads+="$thread"
                new_comment_threads+="\n---\n\n"
            done
        fi
    fi
    
    # Update state file (remove comments field to avoid storing large data)
    local state_to_store=$(echo "$current_state" | jq 'del(.comments)')
    local new_state=$(jq \
        --arg pr "$pr_number" \
        --argjson state "$state_to_store" \
        '.[$pr] = $state' \
        "$STATE_FILE")
    echo "$new_state" > "$STATE_FILE"
    
    # Notify if changes detected
    if [[ ${#changes[@]} -gt 0 ]]; then
        local title=$(echo "$current_state" | jq -r '.title')
        local change_summary=$(printf '%s\n' "${changes[@]}")
        
        # Build notification with optional comment threads
        local total_comments=$(echo "$curr_comment_ids" | jq 'length')
        local notification="<pr-update>
ðŸ”” PR #$pr_number Update:

$title

Changes:
$change_summary

Current status: $curr_pr_state
Comments: $total_comments
"
        
        # Add new comment threads if any
        if [[ -n "$new_comment_threads" ]]; then
            notification+="
---

$(echo -e "$new_comment_threads")"
        fi
        
        notification+="
Run \`forge pr view $pr_number\` for full details.
</pr-update>"
        
        echo "Changes detected for PR #$pr_number:" >&2
        echo "$change_summary" >&2
        
        # Send notification via pr-notify
        echo "DEBUG: Calling pr-notify with PR #$pr_number" >&2
        echo "DEBUG: OPENCODE_API=${OPENCODE_API:-not set}" >&2
        bash "${SCRIPT_DIR}/pr-notify" "$pr_number" "$notification"
    else
        echo "No changes for PR #$pr_number" >&2
    fi
}

# Find all PRs being worked on in active sessions
find_active_prs() {
    # Use anvil to list sessions in this repo
    SESSIONS=$(bash "${SCRIPT_DIR}/anvil" --list --repo "$REPO_DIR" --json 2>/dev/null)
    if [[ -z "$SESSIONS" ]] || [[ "$SESSIONS" == "[]" ]]; then
        return 0
    fi
    
    # Find all sessions in this repo (sort by last update for multi-session PR work)
    # Don't filter by time - if a PR gets comments after hours of silence, we still want to notify
    # Sort by updated time to prioritize most recently active session
    ACTIVE_SESSIONS=$(echo "$SESSIONS" | jq -r \
        'sort_by(.time.updated) | reverse | .[].id')
    
    if [[ -z "$ACTIVE_SESSIONS" ]]; then
        return 0
    fi
    
    # Extract PR numbers from active sessions, filtering by repo URL
    for SESSION_ID in $ACTIVE_SESSIONS; do
        MESSAGES=$(bash "${SCRIPT_DIR}/anvil" --messages "$SESSION_ID" --limit 100 --json 2>/dev/null)
        
        # Look for PR references: full URLs with repo path, or "PR #NUMBER" mentions
        if [[ -n "$REPO_PATH" ]]; then
            # Prefer full PR URLs with repo path, fall back to "PR #NUMBER" pattern
            SESSION_PRS=$(echo "$MESSAGES" | jq -r \
                --arg repo "$REPO_PATH" \
                '[.[] | .parts[]? | select(.type == "text") | .text // "" | 
                 (select(contains($repo) and contains("/pull/")) | scan("/pull/([0-9]+)"; "g")), 
                 (scan("PR #([0-9]+)"; "gi"))] | 
                 flatten | unique | .[]' 2>/dev/null)
        else
            # Fallback: accept PR URLs or "PR #NUMBER" pattern
            SESSION_PRS=$(echo "$MESSAGES" | jq -r \
                '[.[] | .parts[]? | select(.type == "text") | .text // "" | 
                 scan("(/pull/|PR #)([0-9]+)"; "gi") | .[1]] | 
                 flatten | unique | .[]' 2>/dev/null)
        fi
        
        if [[ -n "$SESSION_PRS" ]]; then
            echo "$SESSION_PRS"
        fi
    done | sort -u
}

# Main polling loop
poll_once() {
    echo "Checking for PR updates..." >&2
    
    # Find active PRs
    local prs=$(find_active_prs)
    
    if [[ -z "$prs" ]]; then
        echo "No active PRs found in sessions" >&2
        return 0
    fi
    
    echo "Monitoring PRs: $prs" >&2
    
    # Check each PR (continue on failure to avoid daemon crash)
    for pr in $prs; do
        check_pr "$pr" || true
    done
}

# Run daemon or single check
if [[ "$DAEMON_MODE" == "true" ]]; then
    echo "Starting PR poll daemon (interval: ${INTERVAL}s, repo: $REPO_DIR)" >&2
    echo "State file: $STATE_FILE" >&2
    echo "OPENCODE_API: ${OPENCODE_API:-NOT SET}" >&2
    echo "Press Ctrl+C to stop" >&2
    
    CYCLE=0
    while true; do
        CYCLE=$((CYCLE + 1))
        echo "=== Cycle $CYCLE at $(date) ===" >&2
        poll_once
        echo "Sleeping for ${INTERVAL}s..." >&2
        sleep "$INTERVAL"
    done
else
    poll_once
fi
