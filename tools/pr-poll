#!/usr/bin/env bash
# PR polling daemon - monitors PR status and notifies on changes
# Usage: pr-poll [--interval SECONDS] [--daemon]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
STATE_FILE="${REPO_DIR}/.pr-poll-state.json"
PID_FILE="${REPO_DIR}/.pr-poll.pid"
INTERVAL=${PR_POLL_INTERVAL:-30}
DAEMON_MODE=false
SESSION_ID=""
WATCH_PRS=""

# Check if repo uses GitHub (pr-poll only supports GitHub currently)
FORGE_TYPE=$(bash "${SCRIPT_DIR}/forge" --type 2>/dev/null || echo "unknown")
if [[ "$FORGE_TYPE" != "github" ]]; then
    echo "pr-poll only supports GitHub repositories (detected: $FORGE_TYPE)" >&2
    echo "Skipping PR polling." >&2
    exit 0
fi

# Get git remote URL to filter sessions working on this specific repo
GIT_REMOTE=$(git remote get-url origin 2>/dev/null || echo "")
if [[ -n "$GIT_REMOTE" ]]; then
    # Extract repo path from URL (works for both SSH and HTTPS)
    # git@github.com:owner/repo.git -> github.com/owner/repo
    # https://github.com/owner/repo.git -> github.com/owner/repo
    REPO_PATH=$(echo "$GIT_REMOTE" | sed -E 's#^(https://|git@)##' | sed 's#:#/#' | sed 's#\.git$##')
else
    REPO_PATH=""
fi

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --interval)
            INTERVAL="$2"
            shift 2
            ;;
        --daemon)
            DAEMON_MODE=true
            shift
            ;;
        --session)
            SESSION_ID="$2"
            shift 2
            ;;
        --pr)
            WATCH_PRS="$2"
            shift 2
            ;;
        --help|-h)
            cat <<EOF
PR polling daemon - monitors PR status and notifies on changes

Usage:
  pr-poll                              # Run once, check for changes
  pr-poll --daemon                     # Run continuously (every 30s)
  pr-poll --daemon --session <id>      # Session-scoped daemon
  pr-poll --daemon --session <id> --pr <nums>  # Watch specific PRs
  pr-poll --interval 60                # Custom interval in seconds

Session-scoped daemon:
  Started by spr/forge wrappers for specific session + PRs.
  Stops when session ends or PRs are closed.

State file: ${REPO_DIR}/.pr-poll-state.json

Add .pr-poll-state.json to .gitignore
EOF
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# Initialize state file if doesn't exist
if [[ ! -f "$STATE_FILE" ]]; then
    echo '{}' > "$STATE_FILE"
fi

save_state_atomic() {
    local pr="$1"
    local state="$2"
    
    local state_to_store=$(echo "$state" | jq 'del(.comments)')
    
    local current_state=$(cat "$STATE_FILE" 2>/dev/null || echo '{}')
    
    local new_state=$(echo "$current_state" | jq \
        --arg pr "$pr" \
        --argjson state "$state_to_store" \
        '.[$pr] = $state')
    
    if ! echo "$new_state" | jq empty 2>/dev/null; then
        echo "ERROR: Invalid JSON generated, aborting write" >&2
        return 1
    fi
    
    local temp_file="${STATE_FILE}.tmp.$$"
    echo "$new_state" > "$temp_file"
    mv "$temp_file" "$STATE_FILE"
}

# Format a single comment for display
format_comment() {
    local comment="$1"
    local is_reply="$2"  # true if this is a reply in a thread
    
    local id=$(echo "$comment" | jq -r '.id')
    local author=$(echo "$comment" | jq -r '.user.login')
    local body=$(echo "$comment" | jq -r '.body')
    local path=$(echo "$comment" | jq -r '.path // "general"')
    local position=$(echo "$comment" | jq -r '.position // .original_position // "null"')
    local diff_hunk=$(echo "$comment" | jq -r '.diff_hunk // ""')
    
    local output=""
    if [[ "$is_reply" == "true" ]]; then
        output="  â†³ Reply to previous comment\n"
    fi
    
    output+="[$id] $path:$position @$author\n"
    output+="$body\n"
    
    if [[ -n "$diff_hunk" ]]; then
        output+="$diff_hunk\n"
    fi
    
    echo -e "$output"
}

# Build thread context for a comment (walks up to root, then formats entire thread)
build_comment_thread() {
    local all_comments="$1"
    local comment_id="$2"
    
    # Find the comment
    local comment=$(echo "$all_comments" | jq --argjson id "$comment_id" '
        (.general + .review) | map(select(.id == $id)) | .[0]
    ')
    
    if [[ "$comment" == "null" ]]; then
        return
    fi
    
    # Walk up to find root comment
    local root_id="$comment_id"
    local current_id="$comment_id"
    while true; do
        local in_reply_to=$(echo "$all_comments" | jq --argjson id "$current_id" '
            (.general + .review) | map(select(.id == $id)) | .[0].in_reply_to_id // null
        ')
        if [[ "$in_reply_to" == "null" ]]; then
            root_id="$current_id"
            break
        fi
        current_id="$in_reply_to"
        root_id="$current_id"
    done
    
    # Collect all comments in thread (root + all descendants)
    local thread_comments=$(echo "$all_comments" | jq --argjson root "$root_id" '
        (.general + .review) as $all |
        # Find root and all comments that reply to root (directly or indirectly)
        $all | map(select(
            .id == $root or .in_reply_to_id == $root
        ))
    ')
    
    # Format thread
    local output=""
    local is_first=true
    while IFS= read -r thread_comment; do
        if [[ "$is_first" == "true" ]]; then
            output+=$(format_comment "$thread_comment" "false")
            is_first=false
        else
            output+="\n"
            output+=$(format_comment "$thread_comment" "true")
        fi
    done < <(echo "$thread_comments" | jq -c '.[]')
    
    echo -e "$output"
}

# Get current PR state from forge
get_pr_state() {
    local pr_number="$1"
    local state=$(bash "${SCRIPT_DIR}/forge" pr view "$pr_number" --json 2>/dev/null)
    if [[ -z "$state" ]]; then
        echo "{}"
        return 1
    fi
    
    # Get all comments (including bot comments for state tracking)
    local comments=$(bash "${SCRIPT_DIR}/forge" pr comments "$pr_number" --json 2>/dev/null || echo '{"general":[],"review":[]}')
    
    # Track ALL comment IDs in state (including bot comments)
    local all_comment_ids=$(echo "$comments" | jq '
        (.general + .review) | map(.id)
    ')
    
    echo "$state" | jq \
        --argjson ids "$all_comment_ids" \
        --argjson comments "$comments" \
        '. + {comment_ids: $ids, comments: $comments, last_check: now}'
}

# Check for changes and notify if needed
check_pr() {
    local pr_number="$1"
    local explicit_session="${2:-}"
    
    local current_state=$(get_pr_state "$pr_number")
    if [[ "$current_state" == "{}" ]]; then
        echo "Failed to fetch PR #$pr_number state" >&2
        return 1
    fi
    
    local previous_state=$(jq --arg pr "$pr_number" '.[$pr] // {}' "$STATE_FILE")
    
    local curr_pr_state=$(echo "$current_state" | jq -r '.state')
    local prev_pr_state=$(echo "$previous_state" | jq -r '.state // "unknown"')
    
    if [[ "$prev_pr_state" == "null" || -z "$prev_pr_state" ]]; then
        prev_pr_state="unknown"
    fi
    
    local curr_comment_ids=$(echo "$current_state" | jq -r '.comment_ids // []')
    local prev_comment_ids=$(echo "$previous_state" | jq -r '.comment_ids // []')
    
    local new_comment_ids=$(echo "$curr_comment_ids" | jq -r --argjson prev "$prev_comment_ids" '
        map(select(. as $id | $prev | index($id) | not))
    ')
    
    local all_comments=$(echo "$current_state" | jq -r '.comments')
    local new_non_bot_ids=$(echo "$all_comments" | jq -r --argjson new_ids "$new_comment_ids" '
        (.general + .review) | 
        map(select(
            (.id as $id | $new_ids | index($id) != null) and
            (.body | endswith("*ðŸ¤– Posted by agent*") | not)
        )) | 
        map(.id)
    ')
    
    local changes=()
    local new_comment_threads=""
    if [[ "$prev_pr_state" == "unknown" ]]; then
        echo "First check for PR #$pr_number - no notification" >&2
    else
        if [[ "$curr_pr_state" != "$prev_pr_state" ]]; then
            changes+=("Status changed: $prev_pr_state â†’ $curr_pr_state")
        fi
        
        local new_ids_array=($(echo "$new_non_bot_ids" | jq -r '.[]'))
        if [[ ${#new_ids_array[@]} -gt 0 ]]; then
            changes+=("${#new_ids_array[@]} new comment(s)")
            
            new_comment_threads+="New comments:\n\n"
            for comment_id in "${new_ids_array[@]}"; do
                local thread=$(build_comment_thread "$all_comments" "$comment_id")
                new_comment_threads+="$thread"
                new_comment_threads+="\n---\n\n"
            done
        fi
    fi
    
    save_state_atomic "$pr_number" "$current_state"
    
    if [[ ${#changes[@]} -gt 0 ]]; then
        local title=$(echo "$current_state" | jq -r '.title')
        local change_summary=$(printf '%s\n' "${changes[@]}")
        
        local total_comments=$(echo "$curr_comment_ids" | jq 'length')
        
        local spr_stack_status=""
        if git branch -r 2>/dev/null | grep -q "origin/spr/"; then
            local spr_status=$(spr status 2>/dev/null || echo "")
            if [[ -n "$spr_status" ]]; then
                spr_stack_status="

Stack Status:
\`\`\`
$spr_status
\`\`\`"
            fi
        fi
        
        local notification="<pr-update>
ðŸ”” PR #$pr_number Update:

$title

Changes:
$change_summary

Current status: $curr_pr_state
Comments: $total_comments
$spr_stack_status"
        
        if [[ -n "$new_comment_threads" ]]; then
            notification+="

---

$(echo -e "$new_comment_threads")"
        fi
        
        notification+="

Run \`forge pr view $pr_number\` for full details.
</pr-update>"
        
        echo "Changes detected for PR #$pr_number:" >&2
        echo "$change_summary" >&2
        
        if [[ -n "$explicit_session" ]]; then
            bash "${SCRIPT_DIR}/pr-notify" "$pr_number" "$notification" "$explicit_session"
        else
            bash "${SCRIPT_DIR}/pr-notify" "$pr_number" "$notification"
        fi
    else
        echo "No changes for PR #$pr_number" >&2
    fi
}

find_active_prs() {
    if [[ -n "$WATCH_PRS" ]]; then
        echo "$WATCH_PRS" | tr ',' '\n'
        return 0
    fi
    
    SESSIONS=$(bash "${SCRIPT_DIR}/anvil" --list --repo "$REPO_DIR" --json 2>/dev/null)
    if [[ -z "$SESSIONS" ]] || [[ "$SESSIONS" == "[]" ]]; then
        return 0
    fi
    
    ACTIVE_SESSIONS=$(echo "$SESSIONS" | jq -r \
        'sort_by(.time.updated) | reverse | .[].id')
    
    if [[ -z "$ACTIVE_SESSIONS" ]]; then
        return 0
    fi
    
    for SESSION_ID in $ACTIVE_SESSIONS; do
        MESSAGES=$(bash "${SCRIPT_DIR}/anvil" --messages "$SESSION_ID" --limit 100 --json 2>/dev/null)
        
        if [[ -n "$REPO_PATH" ]]; then
            SESSION_PRS=$(echo "$MESSAGES" | jq -r \
                --arg repo "$REPO_PATH" \
                '[.[] | .parts[]? | select(.type == "text") | .text // "" | 
                 (select(contains($repo) and contains("/pull/")) | scan("/pull/([0-9]+)"; "g")), 
                 (scan("PR #([0-9]+)"; "gi"))] | 
                 flatten | unique | .[]' 2>/dev/null)
        else
            SESSION_PRS=$(echo "$MESSAGES" | jq -r \
                '[.[] | .parts[]? | select(.type == "text") | .text // "" | 
                 scan("(/pull/|PR #)([0-9]+)"; "gi") | .[1]] | 
                 flatten | unique | .[]' 2>/dev/null)
        fi
        
        if [[ -n "$SESSION_PRS" ]]; then
            echo "$SESSION_PRS"
        fi
    done | sort -u
}

poll_once() {
    echo "Checking for PR updates..." >&2
    
    local prs=$(find_active_prs)
    
    if [[ -z "$prs" ]]; then
        echo "No active PRs found" >&2
        return 0
    fi
    
    echo "Monitoring PRs: $prs" >&2
    
    for pr in $prs; do
        check_pr "$pr" "$SESSION_ID" || true
    done
}

cleanup_daemon() {
    if [[ -f "$PID_FILE" ]] && [[ "$(cat "$PID_FILE" 2>/dev/null)" == "$$" ]]; then
        rm -f "$PID_FILE"
    fi
}

if [[ "$DAEMON_MODE" == "true" ]]; then
    if [[ -n "$SESSION_ID" ]]; then
        if [[ -f "$PID_FILE" ]]; then
            OLD_PID=$(cat "$PID_FILE" 2>/dev/null || echo "")
            if [[ -n "$OLD_PID" ]] && kill -0 "$OLD_PID" 2>/dev/null; then
                echo "Daemon already running (PID $OLD_PID)" >&2
                exit 0
            fi
            rm -f "$PID_FILE"
        fi
        
        echo $$ > "$PID_FILE"
        trap cleanup_daemon EXIT INT TERM
        
        echo "Starting session-scoped daemon (session: $SESSION_ID)" >&2
        if [[ -n "$WATCH_PRS" ]]; then
            echo "Watching PRs: $WATCH_PRS" >&2
        fi
    else
        echo "Starting PR poll daemon (interval: ${INTERVAL}s)" >&2
        echo "WARNING: Global daemon mode deprecated, use --session flag" >&2
    fi
    
    echo "State file: $STATE_FILE" >&2
    echo "OPENCODE_API: ${OPENCODE_API:-NOT SET}" >&2
    
    CYCLE=0
    while true; do
        CYCLE=$((CYCLE + 1))
        echo "=== Cycle $CYCLE at $(date) ===" >&2
        poll_once
        echo "Sleeping for ${INTERVAL}s..." >&2
        sleep "$INTERVAL"
    done
else
    poll_once
fi
